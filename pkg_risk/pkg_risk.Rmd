---
title: "pgk_risk"
output: github_document
---

*Very* basic and cursory study on package use as package risk.  The conclusion is: packages on CRAN tend not to be in a bad state (defined as one of FAIL, ERROR, WARN) but historically each additional package in Depends or Imports adds a 0.7% chance of being observed in the bad state (very small) or in relative terms an extra 11% relative-chance of being observed in the bad state (a moderately large effect). 

This model sees packages at the import level of `dplyr` as implying a an 11% problem rate and packages at the import level of `tidyverse` implying a 42% problem rate.  Both of these are far in excess of the current CRAN problem rate of 7.4%

There is a heavy censorship issue (CRAN tends to remove error packages). Additional confounding factor is package use decreases chance of a package being observed in the Note state.  Obvious omitted points: package complexity in general and package authors.

```{r}
library("wrapr")

# load package facts
cran <- tools::CRAN_package_db()
cr <- tools::CRAN_check_results()

# convert comma separated list into
# sequence of non-core package names
parse_lists <- function(strs) {
  strs[is.na(strs)] <- ""
  strs <- gsub("[(][^)]*[)]", "", strs)
  strs <- gsub("\\s+", "", strs)
  strs <- strsplit(strs, ",", fixed=TRUE)
  strs <- lapply(
    strs,
    function(si) {
      setdiff(si, c("", "R", 
                    "base", "compiler", "datasets", 
                    "graphics", "grDevices", "grid",
                    "methods", "parallel", "splines", 
                    "stats", "stats4", "tcltk", "tools",
                    "translations", "utils"))
    })
  strs
}

# collect the columns we want
d <- data.frame(
  Package = cran$Package,
  stringsAsFactors = FALSE)
d$Depends <- parse_lists(cran$Depends)
d$nDepends <- vapply(d$Depends, length, numeric(1))
d$Imports <- parse_lists(cran$Imports)
d$nImports <- vapply(d$Imports, length, numeric(1))
d$nUsing <- d$nDepends + d$nImports

# map check status into our data
d$Status <- NA_character_
smap <- as.character(cr$Status)
names(smap) <- as.character(cr$Package)
d$Status <- smap[d$Package]

# take a look
head(d)

# summarize status
table(d$Status, useNA = "ifany")

# build a simple model
m <- glm(Status!="OK" ~ nUsing,
         data = d,
         family = binomial)
summary(m)
# notice more package use reduces chance of Status!="OK"
# however, we are mostly modeing if status is OK versus NOTE.

# build a simple model on bad states
d$bad_status <- d$Status %in% c("ERROR", "FAIL", "WARN")
m <- glm(bad_status ~ nUsing,
           data = d,
           family = binomial)
summary(m)

# try to interpret
pred <- predict(m, newdata = d, type = "response")
d2 <- d
d2$nUsing <- d$nUsing + 1
pred_plus <- predict(m, newdata = d2, type = "response")

# bad status is rare (CRAN removes bad packages)
summary(d$bad_status)

mean(d$bad_status)

# the absolute risk of each additional dependency is low
summary(pred_plus - pred)

# the relative risk of each additional dependency is medium
summary(pred_plus / pred)

d$predicted_problem_probability <- pred

d[d$Package %in% c("dplyr", "tidyverse"), 
  c("Package", "nDepends", "nImports", "Status", "predicted_problem_probability")] %.>%
  knitr::kable(.)
```

